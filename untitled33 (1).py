# -*- coding: utf-8 -*-
"""Untitled33.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18-PvuwiUf6CBdqUVjxYN3xitbXswMPmU
"""

import yfinance as yf
import pandas as pd
import numpy as np
from sklearn.preprocessing import MinMaxScaler
from keras.models import Sequential
from keras.layers import Conv1D, MaxPooling1D, Flatten, LSTM, Dense, TimeDistributed
from scipy.optimize import linprog
import matplotlib.pyplot as plt

# 1. Captura de datos
dow_jones_companies = [
    "AAPL", "MSFT", "V", "PG", "JNJ", "HD", "NVDA", "UNH", "AMZN", "GOOG",
    "AXP", "BA", "CAT", "CRM", "CSCO", "CVX", "DIS", "DOW", "GS", "HON",
    "IBM", "INTC", "MMM", "MRK", "NKE", "TRV", "WBA", "WMT", "XOM", "KO"
]

start_date = "2024-01-01"
end_date = "2024-01-31"
data = {}

for company in dow_jones_companies:
    ticker = yf.Ticker(company)
    hist = ticker.history(start=start_date, end=end_date)
    data[company] = hist['Close']

# Crear DataFrame con precios al cierre
df = pd.DataFrame(data)
df = df.dropna()
print(f"Datos descargados: {df.shape[0]} días de precios")
print(df.head())

# 2. Preparación de datos
scaler = MinMaxScaler(feature_range=(0, 1))
scaled_data = scaler.fit_transform(df.values)

# Crear secuencias para el modelo CNN-LSTM
def create_sequences(data, n_steps=15):
    X, y = [], []
    for i in range(len(data) - n_steps):
        X.append(data[i:i + n_steps])
        y.append(data[i + n_steps])
    return np.array(X), np.array(y)

n_steps = 15
if len(scaled_data) <= n_steps:
    print(f"Datos insuficientes para n_steps={n_steps}. Reduce n_steps o usa más datos.")
    n_steps = len(scaled_data) - 1

X, y = create_sequences(scaled_data, n_steps)

# Dividir datos en entrenamiento y prueba
split = int(len(X) * 0.8)
X_train, X_test = X[:split], X[split:]
y_train, y_test = y[:split], y[split:]

print(f"X_train: {X_train.shape}, y_train: {y_train.shape}")

# Ajustar dimensiones de entrada
X_train = X_train.reshape((X_train.shape[0], 1, X_train.shape[1], X_train.shape[2]))
X_test = X_test.reshape((X_test.shape[0], 1, X_test.shape[1], X_test.shape[2]))

# 3. Creación y ajuste del modelo CNN-LSTM
model = Sequential()
model.add(TimeDistributed(Conv1D(filters=64, kernel_size=3, activation='relu'), input_shape=(None, n_steps, len(dow_jones_companies))))
model.add(TimeDistributed(MaxPooling1D(pool_size=2)))
model.add(TimeDistributed(Flatten()))
model.add(LSTM(50, activation='relu', return_sequences=False))
model.add(Dense(len(dow_jones_companies)))
model.compile(optimizer='adam', loss='mse')

history = model.fit(X_train, y_train, epochs=50, batch_size=32, validation_data=(X_test, y_test), verbose=2)

# Evaluar modelo
loss = model.evaluate(X_test, y_test, verbose=0)
print(f"Pérdida en datos de prueba: {loss:.4f}")

# Visualizar la pérdida
plt.plot(history.history['loss'], label='Entrenamiento')
plt.plot(history.history['val_loss'], label='Validación')
plt.title('Pérdida del modelo')
plt.xlabel('Épocas')
plt.ylabel('Pérdida')
plt.legend()
plt.show()

# 4. Selección de portafolio mediante optimización
# Predecir precios para el 20 de enero
X_last = scaled_data[-n_steps:].reshape((1, 1, n_steps, len(dow_jones_companies)))
predicted_prices = model.predict(X_last)
predicted_prices = scaler.inverse_transform(predicted_prices)

# Calcular rendimientos proyectados
prices = df.iloc[-1].values  # Precios al 17 de enero
returns = []
for i, company in enumerate(dow_jones_companies):
    projected_return = (predicted_prices[0][i] - prices[i]) / prices[i]
    returns.append(projected_return)

# Configuración para optimización
costs = prices  # Costo por acción al 17 de enero
profits = np.array(returns) * costs  # Ganancia proyectada por acción
total_budget = 20000000
num_companies = len(dow_jones_companies)

bounds = [(0, 1) for _ in range(num_companies)]  # Variables binarias
A_eq = np.array([costs])  # Restricción de presupuesto
b_eq = [total_budget]
c = -profits  # Maximizar ganancias = minimizar -ganancias

# Resolver problema de optimización
result = linprog(c, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method="highs")

# Extraer resultados
selected = np.round(result.x).astype(int)
selected_companies = [dow_jones_companies[i] for i in range(num_companies) if selected[i] == 1]
selected_profits = [profits[i] for i in range(num_companies) if selected[i] == 1]